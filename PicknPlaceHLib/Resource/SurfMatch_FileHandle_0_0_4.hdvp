<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.2.0">
<procedure name="SurfMatch_FileHandle_0_0_4">
<interface>
<oo>
<par name="RGB_Scene" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="plyFilename" base_type="ctrl" dimension="0"/>
<par name="sfmFileName" base_type="ctrl" dimension="0"/>
<par name="om3FileName" base_type="ctrl" dimension="0"/>
<par name="SimpleObjMatch" base_type="ctrl" dimension="0"/>
<par name="BOXLengthX" base_type="ctrl" dimension="0"/>
<par name="BOXLengthY" base_type="ctrl" dimension="0"/>
<par name="BOXLengthZ" base_type="ctrl" dimension="0"/>
<par name="SphereRadius" base_type="ctrl" dimension="0"/>
<par name="CylinderRadius" base_type="ctrl" dimension="0"/>
<par name="CylinderZMinExt" base_type="ctrl" dimension="0"/>
<par name="CylinderZMaxExt" base_type="ctrl" dimension="0"/>
<par name="SimpleModelSampleVal" base_type="ctrl" dimension="0"/>
<par name="CreateSFMSampleVal" base_type="ctrl" dimension="0"/>
<par name="RoiForm" base_type="ctrl" dimension="0"/>
<par name="MatchForm" base_type="ctrl" dimension="0"/>
<par name="ScanXArea" base_type="ctrl" dimension="0"/>
<par name="ScanXOverwrap" base_type="ctrl" dimension="0"/>
<par name="ROIXAreaMin" base_type="ctrl" dimension="0"/>
<par name="ROIXAreaMax" base_type="ctrl" dimension="0"/>
<par name="ROIYAreaMin" base_type="ctrl" dimension="0"/>
<par name="ROIYAreaMax" base_type="ctrl" dimension="0"/>
<par name="ROIZPlaneMinDepth" base_type="ctrl" dimension="0"/>
<par name="ROIZPlaneMaxDepth" base_type="ctrl" dimension="0"/>
<par name="sampleMethod" base_type="ctrl" dimension="0"/>
<par name="sampleValue" base_type="ctrl" dimension="0"/>
<par name="RelSamplingDistance" base_type="ctrl" dimension="0"/>
<par name="KeyPointFraction" base_type="ctrl" dimension="0"/>
<par name="MinScore" base_type="ctrl" dimension="0"/>
<par name="NumMatch" base_type="ctrl" dimension="0"/>
<par name="FindMethod" base_type="ctrl" dimension="0"/>
<par name="ScoreWeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MatchResult" base_type="ctrl" dimension="0"/>
<par name="ObjectModel_Scene" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D_Result" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>dev_update_off ()</l>
<c></c>
<l>*dev_clear_window()</l>
<l>*WinWidth := 1920 / 2 </l>
<l>*WinHeight := 1200 / 2</l>
<l>*dev_open_window(0, 0, WinWidth, WinHeight, 'black', Window3D)</l>
<l>if (SimpleObjMatch == 1)</l>
<l>    gen_box_object_model_3d ([0,0,0,0,0,0,0], BOXLengthX, BOXLengthY, BOXLengthZ, ObjectModel3D)</l>
<l>    *triangulate_object_model_3d (ObjectModel3D, 'greedy', [], [], ObjectModel3D, Information)</l>
<l>    *create_surface_model (ObjectModel3D, CreateSFMSampleVal, 'train_3d_edges', 'true', SFM)</l>
<l>    sample_object_model_3d (ObjectModel3D, 'fast_compute_normals', SimpleModelSampleVal, [], [], ObjectModel3D)</l>
<l>    *create_surface_model (ObjectModel3D, CreateSFMSampleVal, [], [], SFM)</l>
<l>    if(MatchForm == 1)</l>
<l>        triangulate_object_model_3d (ObjectModel3D, 'greedy', [], [], ObjectModel3D, Information)</l>
<l>        create_surface_model (ObjectModel3D, CreateSFMSampleVal, ['train_3d_edges', 'model_invert_normals'], ['true', 'true'], SFM)</l>
<l>    elseif(MatchForm == 2)</l>
<l>        triangulate_object_model_3d (ObjectModel3D, 'greedy', [], [], ObjectModel3D, Information)</l>
<l>        create_surface_model (ObjectModel3D, CreateSFMSampleVal, [], [], SFM)</l>
<l>    else</l>
<l>        create_surface_model (ObjectModel3D, CreateSFMSampleVal, [], [], SFM)</l>
<l>    endif</l>
<l>    get_surface_model_param(SFM, 'sampled_model', SFMModel)</l>
<c>    </c>
<l>elseif (SimpleObjMatch == 2)</l>
<l>    gen_sphere_object_model_3d ([0,0,0,0,0,0,0], SphereRadius, ObjectModel3D)</l>
<l>    *triangulate_object_model_3d (ObjectModel3D, 'greedy', [], [], ObjectModel3D, Information)</l>
<l>    *create_surface_model (ObjectModel3D, CreateSFMSampleVal, 'train_3d_edges', 'true', SFM)</l>
<l>    sample_object_model_3d (ObjectModel3D, 'fast_compute_normals', SimpleModelSampleVal, [], [], ObjectModel3D)</l>
<l>    *create_surface_model (ObjectModel3D, CreateSFMSampleVal, [], [], SFM)</l>
<l>    if(MatchForm == 1)</l>
<l>        triangulate_object_model_3d (ObjectModel3D, 'greedy', [], [], ObjectModel3D, Information)</l>
<l>        create_surface_model (ObjectModel3D, CreateSFMSampleVal, ['train_3d_edges', 'model_invert_normals'], ['true', 'true'], SFM)</l>
<l>    elseif(MatchForm == 2)</l>
<l>        triangulate_object_model_3d (ObjectModel3D, 'greedy', [], [], ObjectModel3D, Information)</l>
<l>        create_surface_model (ObjectModel3D, CreateSFMSampleVal, [], [], SFM)</l>
<l>    else</l>
<l>        create_surface_model (ObjectModel3D, CreateSFMSampleVal, [], [], SFM)</l>
<l>    endif</l>
<l>elseif (SimpleObjMatch == 3)</l>
<l>    gen_cylinder_object_model_3d ([0,0,0,0,0,0,0], CylinderRadius, CylinderZMinExt, CylinderZMaxExt, ObjectModel3D)</l>
<l>    *triangulate_object_model_3d (ObjectModel3D, 'greedy', [], [], ObjectModel3D, Information)</l>
<l>    *create_surface_model (ObjectModel3D, CreateSFMSampleVal, 'train_3d_edges', 'true', SFM)</l>
<l>    sample_object_model_3d (ObjectModel3D, 'fast_compute_normals', SimpleModelSampleVal, [], [], ObjectModel3D)</l>
<l>    *create_surface_model (ObjectModel3D, CreateSFMSampleVal, [], [], SFM)</l>
<l>    if(MatchForm == 1)</l>
<l>        triangulate_object_model_3d (ObjectModel3D, 'greedy', [], [], ObjectModel3D, Information)</l>
<l>        create_surface_model (ObjectModel3D, CreateSFMSampleVal, ['train_3d_edges', 'model_invert_normals'], ['true', 'true'], SFM)</l>
<l>    elseif(MatchForm == 2)</l>
<l>        triangulate_object_model_3d (ObjectModel3D, 'greedy', [], [], ObjectModel3D, Information)</l>
<l>        create_surface_model (ObjectModel3D, CreateSFMSampleVal, [], [], SFM)</l>
<l>    else</l>
<l>        create_surface_model (ObjectModel3D, CreateSFMSampleVal, [], [], SFM)</l>
<l>    endif</l>
<l>else</l>
<c>    *SIMPLEOBJ_MATCH == 0.....</c>
<l>    tuple_add (sfmFileName, '', SFMFilename)</l>
<l>    read_surface_model (SFMFilename, SFM)</l>
<c>    </c>
<c>    * Loading the HALCON 3D object model (used for visualization purpose)</c>
<l>    tuple_add (om3FileName, '', ObjectModel3DFilename)</l>
<l>    read_object_model_3d (ObjectModel3DFilename, 'm', [], [], ObjectModel3D, Status)</l>
<l>endif</l>
<c></c>
<c></c>
<c>* Computing 3D object model normals, which is necessary for surface-based 3D matching</c>
<l>count_seconds (T0)</l>
<l>tuple_add(plyFilename,'', SceneFilename)</l>
<l>read_object_model_3d (SceneFilename, 'm', ['xyz_map_width'], [1920], ObjectModel_Scene, Status)</l>
<l>*visualize_object_model_3d (Window3D, [ObjectModel3D_Scene], [], [], [], [], [], [], [], PoseOut)</l>
<l>*stop()</l>
<l>get_object_model_3d_params (ObjectModel_Scene, 'red', red)</l>
<l>get_object_model_3d_params (ObjectModel_Scene, 'green', green)</l>
<l>get_object_model_3d_params (ObjectModel_Scene, 'blue', blue)</l>
<l>set_object_model_3d_attrib (ObjectModel_Scene, '&amp;red', 'points', red, ObjectModel_Scene)</l>
<l>set_object_model_3d_attrib (ObjectModel_Scene, '&amp;green', 'points', green, ObjectModel_Scene)</l>
<l>set_object_model_3d_attrib (ObjectModel_Scene, '&amp;blue', 'points', blue, ObjectModel_Scene)</l>
<c></c>
<l>object_model_3d_to_xyz( X, Y, Z, ObjectModel_Scene, 'from_xyz_map', [], [])  </l>
<l>get_image_size (X, Width, Height)</l>
<l>gen_image_const (R, 'real', Width, Height)</l>
<l>gen_image_const (G, 'real', Width, Height)</l>
<l>gen_image_const (B, 'real', Width, Height)</l>
<l>get_domain (R, Domain)</l>
<l>get_region_points (Domain, Rows, Columns)</l>
<l>set_grayval (R, Rows, Columns, red)</l>
<l>set_grayval (G, Rows, Columns, green)</l>
<l>set_grayval (B, Rows, Columns, blue)</l>
<l>compose3 (R, G, B, RGBA)</l>
<l>xyz_to_object_model_3d (X, Y, Z, ObjectModel_Scene)</l>
<c></c>
<l>if (RoiForm == 1)</l>
<l>    for Index1 := ROIXAreaMin to ROIXAreaMax by ScanXOverwrap</l>
<l>        if(Index1+ScanXArea &gt; ROIXAreaMax )</l>
<l>            RGB_Scene := RGBA</l>
<l>            ObjectModel_Scene := ObjectModel_Scene</l>
<l>            ObjectModel3D_Result := ObjectModel_Scene</l>
<c>            </c>
<l>            MatchResult := 'Faild'</l>
<l>            break</l>
<l>        endif</l>
<c>        </c>
<l>        if (MatchForm == 1)</l>
<l>            xyz_to_object_model_3d (X, Y, Z, ObjectModel_Scene)</l>
<l>            select_points_object_model_3d (ObjectModel_Scene, 'point_coord_x', Index1, Index1+ScanXArea, ObjectModel_Scene)</l>
<l>            sample_object_model_3d (ObjectModel_Scene, sampleMethod, sampleValue, [], [], ObjectModel_Scene)</l>
<c>        </c>
<l>*            smooth_object_model_3d (ObjectModel_Scene, 'mls', ['mls_kNN','mls_force_inwards'], [60,'true'], ObjectModel_Scene)</l>
<l>            triangulate_object_model_3d (ObjectModel_Scene, 'xyz_mapping', [], [], TriangulatedObjectModel3D1, Information)</l>
<l>            fit_primitives_object_model_3d (TriangulatedObjectModel3D1, 'primitive_type', 'plane', ObjectModel3DOut)</l>
<c>            </c>
<l>            get_object_model_3d_params (ObjectModel3DOut, 'primitive_parameter_pose', Pose_primitive_plane)</l>
<c>            </c>
<l>            pose_invert (Pose_primitive_plane, PoseInvert_primitive_plane)</l>
<l>            pose_to_hom_mat3d (PoseInvert_primitive_plane, HomMat3D_invert)</l>
<l>            affine_trans_object_model_3d (TriangulatedObjectModel3D1, HomMat3D_invert, Triangulated_ObjectModel3DAffineTrans)</l>
<c>            </c>
<l>            *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 1, 5, ObjectModel3DThresholded2)</l>
<l>            *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 5, 50, ObjectModel3DThresholded2)</l>
<l>            select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', ROIZPlaneMinDepth, ROIZPlaneMaxDepth, ObjectModel3DThresholded2)</l>
<l>            pose_to_hom_mat3d (Pose_primitive_plane, HomMat3D)</l>
<l>            affine_trans_object_model_3d (ObjectModel3DThresholded2, HomMat3D, ObjectModel3DAffineTrans)</l>
<l>            ObjectModel_Scene := ObjectModel3DAffineTrans</l>
<l>        elseif (MatchForm == 2)</l>
<l>            xyz_to_object_model_3d (X, Y, Z, ObjectModel_Scene)</l>
<l>            select_points_object_model_3d (ObjectModel_Scene, 'point_coord_x', Index1, Index1+ScanXArea, ObjectModel_Scene)</l>
<l>            sample_object_model_3d (ObjectModel_Scene, sampleMethod, sampleValue, [], [], ObjectModel_Scene)</l>
<c>        </c>
<l>*            smooth_object_model_3d (ObjectModel_Scene, 'mls', ['mls_kNN','mls_force_inwards'], [60,'true'], ObjectModel_Scene)</l>
<l>            *triangulate_object_model_3d (ObjectModel_Scene, 'xyz_mapping', [], [], TriangulatedObjectModel3D1, Information)</l>
<l>            fit_primitives_object_model_3d (TriangulatedObjectModel3D1, 'primitive_type', 'plane', ObjectModel3DOut)</l>
<c>            </c>
<l>            get_object_model_3d_params (ObjectModel3DOut, 'primitive_parameter_pose', Pose_primitive_plane)</l>
<c>            </c>
<l>            pose_invert (Pose_primitive_plane, PoseInvert_primitive_plane)</l>
<l>            pose_to_hom_mat3d (PoseInvert_primitive_plane, HomMat3D_invert)</l>
<l>            affine_trans_object_model_3d (TriangulatedObjectModel3D1, HomMat3D_invert, Triangulated_ObjectModel3DAffineTrans)</l>
<c>            </c>
<l>            *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 1, 5, ObjectModel3DThresholded2)</l>
<l>            *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 5, 50, ObjectModel3DThresholded2)</l>
<l>            select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', ROIZPlaneMinDepth, ROIZPlaneMaxDepth, ObjectModel3DThresholded2)</l>
<l>            pose_to_hom_mat3d (Pose_primitive_plane, HomMat3D)</l>
<l>            affine_trans_object_model_3d (ObjectModel3DThresholded2, HomMat3D, ObjectModel3DAffineTrans)</l>
<l>            triangulate_object_model_3d (ObjectModel3DAffineTrans, 'greedy', [], [], TriangulatedObjectModel3D1, Information)</l>
<l>            ObjectModel_Scene := ObjectModel3DAffineTrans</l>
<l>        else</l>
<l>            xyz_to_object_model_3d (X, Y, Z, ObjectModel_Scene)</l>
<l>            select_points_object_model_3d (ObjectModel_Scene, 'point_coord_x', Index1, Index1+ScanXArea, ObjectModel_Scene)</l>
<l>            sample_object_model_3d (ObjectModel_Scene, sampleMethod, sampleValue, [], [], ObjectModel_Scene)</l>
<c>        </c>
<l>*            smooth_object_model_3d (ObjectModel_Scene, 'mls', ['mls_kNN','mls_force_inwards'], [60,'true'], ObjectModel_Scene)</l>
<l>            *triangulate_object_model_3d (ObjectModel_Scene, 'xyz_mapping', [], [], TriangulatedObjectModel3D1, Information)</l>
<l>            fit_primitives_object_model_3d (ObjectModel_Scene, 'primitive_type', 'plane', ObjectModel3DOut)</l>
<c>            </c>
<l>            get_object_model_3d_params (ObjectModel3DOut, 'primitive_parameter_pose', Pose_primitive_plane)</l>
<c>            </c>
<l>            pose_invert (Pose_primitive_plane, PoseInvert_primitive_plane)</l>
<l>            pose_to_hom_mat3d (PoseInvert_primitive_plane, HomMat3D_invert)</l>
<l>            affine_trans_object_model_3d (ObjectModel_Scene, HomMat3D_invert, Triangulated_ObjectModel3DAffineTrans)</l>
<c>            </c>
<l>            *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 1, 5, ObjectModel3DThresholded2)</l>
<l>            *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 5, 50, ObjectModel3DThresholded2)</l>
<l>            select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', ROIZPlaneMinDepth, ROIZPlaneMaxDepth, ObjectModel3DThresholded2)</l>
<l>            pose_to_hom_mat3d (Pose_primitive_plane, HomMat3D)</l>
<l>            affine_trans_object_model_3d (ObjectModel3DThresholded2, HomMat3D, ObjectModel3DAffineTrans)</l>
<l>            ObjectModel_Scene := ObjectModel3DAffineTrans</l>
<l>        endif</l>
<c>        </c>
<l>*        set_surface_model_param (SFM, 'symmetry_poses', [0,0,0,0,0,0,0])</l>
<l>        get_object_model_3d_params (ObjectModel_Scene, 'num_points', Scene_PointNum)</l>
<c>        </c>
<l>        if(Scene_PointNum &lt;= 0)</l>
<l>            continue</l>
<l>        endif</l>
<l>        *find_surface_model_image(img2D, SFM, ObjectModel_Scene, RelSamplingDistance, KeyPointFraction, MinScore, 'true', ['num_matches', 'scene_normal_computation'], [NumMatch, 'mls'], Pose, Score, SurfaceMatchingResultID)</l>
<l>        find_surface_model (SFM, ObjectModel_Scene, RelSamplingDistance, KeyPointFraction, MinScore, 'true', ['num_matches', 'scene_normal_computation', 'score_type', 'max_overlap_dist_rel'], [NumMatch, FindMethod, 'num_scene_points', ScoreWeight], Pose, Score, SurfaceMatchingResultID)</l>
<c></c>
<c>    </c>
<l>        if (Score!=[])</l>
<c>            * Preparing the result(s)</c>
<l>            if (Score[0] &lt; MinScore)</l>
<l>                RGB_Scene := RGBA</l>
<l>                ObjectModel_Scene := ObjectModel_Scene</l>
<l>                ObjectModel3D_Result := ObjectModel_Scene</l>
<c>                </c>
<l>                MatchResult := 'Faild'</l>
<l>                return ()</l>
<l>            endif</l>
<c>            </c>
<l>            tuple_length(Score, SuccessNum)</l>
<l>            VisRotationCenters := []</l>
<l>            CPose := []</l>
<l>            StartNUM := 0</l>
<l>            EndNUM := 6</l>
<l>            for Index := 0 to SuccessNum-1 by 1</l>
<l>                    *CPose[Index] := Pose[0:6]    </l>
<l>                CPose := Pose[StartNUM:EndNUM]</l>
<l>                rigid_trans_object_model_3d (ObjectModel3D, CPose, ObjectModel3D_Result)</l>
<l>                get_object_model_3d_params (ObjectModel3D_Result, 'center', VisRotationCenter)</l>
<l>                VisRotationCenters := [VisRotationCenters,VisRotationCenter]</l>
<l>                StartNUM := StartNUM + 7</l>
<l>                EndNUM := EndNUM + 7</l>
<l>            endfor</l>
<l>            rigid_trans_object_model_3d (ObjectModel3D, Pose, ObjectModel3D_ResultImg)</l>
<c>               </c>
<l>            RGB_Scene := RGBA</l>
<l>            ObjectModel_Scene := ObjectModel_Scene</l>
<l>            ObjectModel3D_Result := ObjectModel3D_ResultImg</l>
<c>            </c>
<l>            VisStart := 0</l>
<l>            PoseStart := 3</l>
<c>            </c>
<l>            SavePoseUR := []</l>
<l>            for Index := 0 to SuccessNum-1 by 1</l>
<l>                SavePose := []</l>
<l>                SavePose[0] := VisRotationCenters[VisStart]</l>
<l>                SavePose[1] := VisRotationCenters[VisStart+1]</l>
<l>                SavePose[2] := VisRotationCenters[VisStart+2]</l>
<l>                SavePose[3] := Pose[PoseStart]</l>
<l>                SavePose[4] := Pose[PoseStart+1]</l>
<l>                SavePose[5] := Pose[PoseStart+2]</l>
<l>                SavePose[6] := 0</l>
<c>                </c>
<l>                *Pose := [VisRotationCenters[VisStart], VisRotationCenters[VisStart+1], VisRotationCenters[VisStart+2], Pose[PoseStart], Pose[PoseStart+1], Pose[PoseStart+1] ,0]</l>
<l>                convert_pose_type (SavePose, 'Rp+T', 'rodriguez', 'point', PoseRodriguez)</l>
<l>                RodLeng := sqrt(sum(PoseRodriguez[3:5]*PoseRodriguez[3:5]))</l>
<l>                AngleInRad := 2*atan(RodLeng)</l>
<l>                UnitAxisOfRotation := PoseRodriguez[3:5]/RodLeng</l>
<l>                OrientationVector := UnitAxisOfRotation*AngleInRad</l>
<l>                PoseUR := [PoseRodriguez[0:2], OrientationVector]</l>
<l>                SavePoseUR := [SavePoseUR, PoseUR]</l>
<l>                VisStart := VisStart + 3</l>
<l>                PoseStart := PoseStart + 7</l>
<l>            endfor</l>
<l>            SavePoseStart := 0</l>
<l>            RTVal := []</l>
<l>            for Index := 0 to SuccessNum-1 by 1</l>
<l>                strMerged := Index+','+ \
                         Score[Index]+','+ \
                         SavePoseUR[SavePoseStart]+','+ \ 
                         SavePoseUR[SavePoseStart+1]+','+ \
                         SavePoseUR[SavePoseStart+2]+','+ \
                         SavePoseUR[SavePoseStart+3]+','+ \
                         SavePoseUR[SavePoseStart+4]+','+ \
                         SavePoseUR[SavePoseStart+5]</l>
<l>                RTVal := [RTVal, strMerged]</l>
<l>                SavePoseStart := SavePoseStart + 6</l>
<l>            endfor</l>
<l>            MatchResult := RTVal</l>
<l>            break</l>
<l>        else</l>
<l>            RGB_Scene := RGBA</l>
<l>            ObjectModel_Scene := ObjectModel_Scene</l>
<l>            ObjectModel3D_Result := ObjectModel_Scene</l>
<c>            </c>
<l>            MatchResult := 'Faild'</l>
<l>        endif</l>
<l>    endfor</l>
<c>    </c>
<l>elseif (RoiForm ==2)</l>
<l>    if (MatchForm == 1)</l>
<l>        RGB_Scene := RGBA</l>
<l>        ObjectModel_Scene := ObjectModel_Scene</l>
<l>        ObjectModel3D_Result := ObjectModel_Scene</l>
<l>        xyz_to_object_model_3d (X, Y, Z, ObjectModel_Scene)</l>
<l>        sample_object_model_3d (ObjectModel_Scene, sampleMethod, sampleValue, [], [], ObjectModel_Scene)</l>
<l>        triangulate_object_model_3d (ObjectModel_Scene, 'xyz_mapping', [], [], TriangulatedObjectModel3D1, Information)</l>
<l>        fit_primitives_object_model_3d (TriangulatedObjectModel3D1, 'primitive_type', 'plane', ObjectModel3DOut)</l>
<c>        </c>
<l>        get_object_model_3d_params (ObjectModel3DOut, 'primitive_parameter_pose', Pose_primitive_plane)</l>
<c>        </c>
<l>        pose_invert (Pose_primitive_plane, PoseInvert_primitive_plane)</l>
<l>        pose_to_hom_mat3d (PoseInvert_primitive_plane, HomMat3D_invert)</l>
<l>        affine_trans_object_model_3d (ObjectModel_Scene, HomMat3D_invert, ObjectModel_Scene)</l>
<c>        </c>
<l>        *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 1, 5, ObjectModel3DThresholded2)</l>
<l>        *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 5, 50, ObjectModel3DThresholded2)</l>
<l>        select_points_object_model_3d (ObjectModel_Scene, 'point_coord_z', ROIZPlaneMinDepth, ROIZPlaneMaxDepth, ObjectModel3DThresholded2)</l>
<l>        pose_to_hom_mat3d (Pose_primitive_plane, HomMat3D)</l>
<l>        affine_trans_object_model_3d (ObjectModel3DThresholded2, HomMat3D, ObjectModel_Scene)</l>
<l>        select_points_object_model_3d (ObjectModel_Scene, 'point_coord_x', ROIXAreaMin, ROIXAreaMax, ObjectModel_Scene)</l>
<l>        select_points_object_model_3d (ObjectModel_Scene, 'point_coord_y', ROIYAreaMin, ROIYAreaMax, ObjectModel_Scene)</l>
<c>        </c>
<l>        *pose_to_hom_mat3d (Pose_primitive_plane, HomMat3D)</l>
<l>        *affine_trans_object_model_3d (ObjectModel3DThresholded2, HomMat3D, ObjectModel3DAffineTrans)</l>
<l>    elseif(MatchForm == 2)</l>
<l>        RGB_Scene := RGBA</l>
<l>        ObjectModel_Scene := ObjectModel_Scene</l>
<l>        ObjectModel3D_Result := ObjectModel_Scene</l>
<l>        xyz_to_object_model_3d (X, Y, Z, ObjectModel_Scene)</l>
<l>        sample_object_model_3d (ObjectModel_Scene, sampleMethod, sampleValue, [], [], ObjectModel_Scene)</l>
<l>        fit_primitives_object_model_3d (ObjectModel_Scene, 'primitive_type', 'plane', ObjectModel3DOut)</l>
<c>        </c>
<l>        get_object_model_3d_params (ObjectModel3DOut, 'primitive_parameter_pose', Pose_primitive_plane)</l>
<c>        </c>
<l>        pose_invert (Pose_primitive_plane, PoseInvert_primitive_plane)</l>
<l>        pose_to_hom_mat3d (PoseInvert_primitive_plane, HomMat3D_invert)</l>
<l>        affine_trans_object_model_3d (ObjectModel_Scene, HomMat3D_invert, ObjectModel_Scene)</l>
<c>        </c>
<l>        *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 1, 5, ObjectModel3DThresholded2)</l>
<l>        *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 5, 50, ObjectModel3DThresholded2)</l>
<l>        select_points_object_model_3d (ObjectModel_Scene, 'point_coord_z', ROIZPlaneMinDepth, ROIZPlaneMaxDepth, ObjectModel3DThresholded2)</l>
<l>        pose_to_hom_mat3d (Pose_primitive_plane, HomMat3D)</l>
<l>        affine_trans_object_model_3d (ObjectModel3DThresholded2, HomMat3D, ObjectModel_Scene)</l>
<l>        select_points_object_model_3d (ObjectModel_Scene, 'point_coord_x', ROIXAreaMin, ROIXAreaMax, ObjectModel_Scene)</l>
<l>        select_points_object_model_3d (ObjectModel_Scene, 'point_coord_y', ROIYAreaMin, ROIYAreaMax, ObjectModel_Scene)</l>
<l>        triangulate_object_model_3d (ObjectModel_Scene, 'greedy', [], [], ObjectModel_Scene, Information)</l>
<l>    else</l>
<l>        RGB_Scene := RGBA</l>
<l>        ObjectModel_Scene := ObjectModel_Scene</l>
<l>        ObjectModel3D_Result := ObjectModel_Scene</l>
<l>        xyz_to_object_model_3d (X, Y, Z, ObjectModel_Scene)</l>
<l>        *select_points_object_model_3d (ObjectModel_Scene, 'point_coord_x', Index1, Index1+ScanXArea, ObjectModel_Scene)</l>
<l>        sample_object_model_3d (ObjectModel_Scene, sampleMethod, sampleValue, [], [], ObjectModel_Scene)</l>
<c>    </c>
<l>*        smooth_object_model_3d (ObjectModel_Scene, 'mls', ['mls_kNN','mls_force_inwards'], [60,'true'], ObjectModel_Scene)</l>
<l>        *triangulate_object_model_3d (ObjectModel_Scene, 'xyz_mapping', [], [], TriangulatedObjectModel3D1, Information)</l>
<l>        fit_primitives_object_model_3d (ObjectModel_Scene, 'primitive_type', 'plane', ObjectModel3DOut)</l>
<c>        </c>
<l>        get_object_model_3d_params (ObjectModel3DOut, 'primitive_parameter_pose', Pose_primitive_plane)</l>
<c>        </c>
<l>        pose_invert (Pose_primitive_plane, PoseInvert_primitive_plane)</l>
<l>        pose_to_hom_mat3d (PoseInvert_primitive_plane, HomMat3D_invert)</l>
<l>        affine_trans_object_model_3d (ObjectModel_Scene, HomMat3D_invert, ObjectModel_Scene)</l>
<c>        </c>
<l>        *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 1, 5, ObjectModel3DThresholded2)</l>
<l>        *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 5, 50, ObjectModel3DThresholded2)</l>
<l>        select_points_object_model_3d (ObjectModel_Scene, 'point_coord_z', ROIZPlaneMinDepth, ROIZPlaneMaxDepth, ObjectModel3DThresholded2)</l>
<l>        pose_to_hom_mat3d (Pose_primitive_plane, HomMat3D)</l>
<l>        affine_trans_object_model_3d (ObjectModel3DThresholded2, HomMat3D, ObjectModel_Scene)</l>
<l>        select_points_object_model_3d (ObjectModel_Scene, 'point_coord_x', ROIXAreaMin, ROIXAreaMax, ObjectModel_Scene)</l>
<l>        select_points_object_model_3d (ObjectModel_Scene, 'point_coord_y', ROIYAreaMin, ROIYAreaMax, ObjectModel_Scene)</l>
<l>        *pose_to_hom_mat3d (Pose_primitive_plane, HomMat3D)</l>
<l>        *affine_trans_object_model_3d (ObjectModel3DThresholded2, HomMat3D, ObjectModel3DAffineTrans)</l>
<l>        *ObjectModel_Scene := ObjectModel3DAffineTrans</l>
<l>    endif</l>
<c></c>
<l>    get_object_model_3d_params (ObjectModel_Scene, 'num_points', Scene_PointNum)</l>
<c>    </c>
<l>    if(Scene_PointNum &lt;= 0)</l>
<l>        RGB_Scene := RGBA</l>
<l>        ObjectModel_Scene := ObjectModel_Scene</l>
<l>        ObjectModel3D_Result := ObjectModel_Scene</l>
<c>        </c>
<l>        MatchResult := 'Faild, ' + Scene_PointNum</l>
<l>        return()</l>
<l>    endif</l>
<l>    *find_surface_model_image(img2D, SFM, ObjectModel_Scene, RelSamplingDistance, KeyPointFraction, MinScore, 'true', ['num_matches', 'scene_normal_computation'], [NumMatch, 'mls'], Pose, Score, SurfaceMatchingResultID)</l>
<l>    find_surface_model (SFM, ObjectModel_Scene, RelSamplingDistance, KeyPointFraction, MinScore, 'true', ['num_matches', 'scene_normal_computation'], [NumMatch, 'mls'], Pose, Score, SurfaceMatchingResultID)</l>
<c></c>
<l>    if (Score!=[])</l>
<c>        * Preparing the result(s)</c>
<l>        if (Score[0] &lt; MinScore)</l>
<l>            RGB_Scene := RGBA</l>
<l>            ObjectModel_Scene := ObjectModel_Scene</l>
<l>            ObjectModel3D_Result := ObjectModel_Scene</l>
<c>            </c>
<l>            MatchResult := 'Faild, ' + Score[0]</l>
<l>            return()</l>
<l>        endif</l>
<c>        </c>
<l>        tuple_length(Score, SuccessNum)</l>
<l>        VisRotationCenters := []</l>
<l>        CPose := []</l>
<l>        StartNUM := 0</l>
<l>        EndNUM := 6</l>
<l>        for Index := 0 to SuccessNum-1 by 1</l>
<l>                *CPose[Index] := Pose[0:6]    </l>
<l>            CPose := Pose[StartNUM:EndNUM]</l>
<l>            rigid_trans_object_model_3d (ObjectModel3D, CPose, ObjectModel3D_Result)</l>
<l>            get_object_model_3d_params (ObjectModel3D_Result, 'center', VisRotationCenter)</l>
<l>            VisRotationCenters := [VisRotationCenters,VisRotationCenter]</l>
<l>            StartNUM := StartNUM + 7</l>
<l>            EndNUM := EndNUM + 7</l>
<l>        endfor</l>
<l>        rigid_trans_object_model_3d (ObjectModel3D, Pose, ObjectModel3D_ResultImg)</l>
<c>   </c>
<l>        RGB_Scene := RGBA</l>
<l>        ObjectModel_Scene := ObjectModel_Scene</l>
<l>        ObjectModel3D_Result := ObjectModel3D_ResultImg</l>
<c>        </c>
<l>        VisStart := 0</l>
<l>        PoseStart := 3</l>
<c>        </c>
<l>        SavePoseUR := []</l>
<l>        for Index := 0 to SuccessNum-1 by 1</l>
<l>            SavePose := []</l>
<l>            SavePose[0] := VisRotationCenters[VisStart]</l>
<l>            SavePose[1] := VisRotationCenters[VisStart+1]</l>
<l>            SavePose[2] := VisRotationCenters[VisStart+2]</l>
<l>            SavePose[3] := Pose[PoseStart]</l>
<l>            SavePose[4] := Pose[PoseStart+1]</l>
<l>            SavePose[5] := Pose[PoseStart+2]</l>
<l>            SavePose[6] := 0</l>
<c>            </c>
<l>            *Pose := [VisRotationCenters[VisStart], VisRotationCenters[VisStart+1], VisRotationCenters[VisStart+2], Pose[PoseStart], Pose[PoseStart+1], Pose[PoseStart+1] ,0]</l>
<l>            convert_pose_type (SavePose, 'Rp+T', 'rodriguez', 'point', PoseRodriguez)</l>
<l>            RodLeng := sqrt(sum(PoseRodriguez[3:5]*PoseRodriguez[3:5]))</l>
<l>            AngleInRad := 2*atan(RodLeng)</l>
<l>            UnitAxisOfRotation := PoseRodriguez[3:5]/RodLeng</l>
<l>            OrientationVector := UnitAxisOfRotation*AngleInRad</l>
<l>            PoseUR := [PoseRodriguez[0:2], OrientationVector]</l>
<l>            SavePoseUR := [SavePoseUR, PoseUR]</l>
<l>            VisStart := VisStart + 3</l>
<l>            PoseStart := PoseStart + 7</l>
<l>        endfor</l>
<l>        SavePoseStart := 0</l>
<l>        RTVal := []</l>
<l>        for Index := 0 to SuccessNum-1 by 1</l>
<l>            strMerged := Index+','+ \
                     Score[Index]+','+ \
                     SavePoseUR[SavePoseStart]+','+ \ 
                     SavePoseUR[SavePoseStart+1]+','+ \
                     SavePoseUR[SavePoseStart+2]+','+ \
                     SavePoseUR[SavePoseStart+3]+','+ \
                     SavePoseUR[SavePoseStart+4]+','+ \
                     SavePoseUR[SavePoseStart+5]</l>
<l>            RTVal := [RTVal, strMerged]</l>
<l>            SavePoseStart := SavePoseStart + 6</l>
<l>        endfor</l>
<l>        MatchResult := RTVal</l>
<l>    else</l>
<l>        RGB_Scene := RGBA</l>
<l>        ObjectModel_Scene := ObjectModel_Scene</l>
<l>        ObjectModel3D_Result := ObjectModel_Scene</l>
<c>        </c>
<l>        MatchResult := 'Faild, Not Matched'</l>
<l>    endif</l>
<l>else</l>
<l>    if (MatchForm == 1)</l>
<l>        RGB_Scene := RGBA</l>
<l>        ObjectModel_Scene := ObjectModel_Scene</l>
<l>        ObjectModel3D_Result := ObjectModel_Scene</l>
<l>        xyz_to_object_model_3d (X, Y, Z, ObjectModel_Scene)</l>
<l>        *select_points_object_model_3d (ObjectModel_Scene, 'point_coord_x', Index1, Index1+ScanXArea, ObjectModel_Scene)</l>
<l>        sample_object_model_3d (ObjectModel_Scene, sampleMethod, sampleValue, [], [], ObjectModel_Scene)</l>
<c>    </c>
<l>*        smooth_object_model_3d (ObjectModel_Scene, 'mls', ['mls_kNN','mls_force_inwards'], [60,'true'], ObjectModel_Scene)</l>
<l>        triangulate_object_model_3d (ObjectModel_Scene, 'xyz_mapping', [], [], TriangulatedObjectModel3D1, Information)</l>
<l>        *visualize_object_model_3d (Window3D, [TriangulatedObjectModel3D1], [], [], [], [], [], [], [], PoseOut)</l>
<l>        *fit_primitives_object_model_3d (TriangulatedObjectModel3D1, 'primitive_type', 'plane', ObjectModel3DOut)</l>
<c>        </c>
<l>        *get_object_model_3d_params (ObjectModel3DOut, 'primitive_parameter_pose', Pose_primitive_plane)</l>
<c>        </c>
<l>        *pose_invert (Pose_primitive_plane, PoseInvert_primitive_plane)</l>
<l>        *pose_to_hom_mat3d (PoseInvert_primitive_plane, HomMat3D_invert)</l>
<l>        *affine_trans_object_model_3d (TriangulatedObjectModel3D1, HomMat3D_invert, Triangulated_ObjectModel3DAffineTrans)</l>
<c>        </c>
<l>        *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 1, 5, ObjectModel3DThresholded2)</l>
<l>        *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 5, 50, ObjectModel3DThresholded2)</l>
<l>        *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', ZPlaneMinDepth, ZPlaneMaxDepth, ObjectModel3DThresholded2)</l>
<l>        *pose_to_hom_mat3d (Pose_primitive_plane, HomMat3D)</l>
<l>        *affine_trans_object_model_3d (ObjectModel3DThresholded2, HomMat3D, ObjectModel3DAffineTrans)</l>
<l>        ObjectModel_Scene := TriangulatedObjectModel3D1</l>
<l>    elseif(MatchForm == 2)</l>
<l>        RGB_Scene := RGBA</l>
<l>        ObjectModel_Scene := ObjectModel_Scene</l>
<l>        ObjectModel3D_Result := ObjectModel_Scene</l>
<l>        xyz_to_object_model_3d (X, Y, Z, ObjectModel_Scene)</l>
<l>        *select_points_object_model_3d (ObjectModel_Scene, 'point_coord_x', Index1, Index1+ScanXArea, ObjectModel_Scene)</l>
<l>        sample_object_model_3d (ObjectModel_Scene, sampleMethod, sampleValue, [], [], ObjectModel_Scene)</l>
<c>    </c>
<l>*        smooth_object_model_3d (ObjectModel_Scene, 'mls', ['mls_kNN','mls_force_inwards'], [60,'true'], ObjectModel_Scene)</l>
<l>        triangulate_object_model_3d (ObjectModel_Scene, 'greedy', [], [], TriangulatedObjectModel3D1, Information)</l>
<l>        *visualize_object_model_3d (Window3D, [TriangulatedObjectModel3D1], [], [], [], [], [], [], [], PoseOut)</l>
<l>        *fit_primitives_object_model_3d (TriangulatedObjectModel3D1, 'primitive_type', 'plane', ObjectModel3DOut)</l>
<c>        </c>
<l>        *get_object_model_3d_params (ObjectModel3DOut, 'primitive_parameter_pose', Pose_primitive_plane)</l>
<c>        </c>
<l>        *pose_invert (Pose_primitive_plane, PoseInvert_primitive_plane)</l>
<l>        *pose_to_hom_mat3d (PoseInvert_primitive_plane, HomMat3D_invert)</l>
<l>        *affine_trans_object_model_3d (TriangulatedObjectModel3D1, HomMat3D_invert, Triangulated_ObjectModel3DAffineTrans)</l>
<c>        </c>
<l>        *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 1, 5, ObjectModel3DThresholded2)</l>
<l>        *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 5, 50, ObjectModel3DThresholded2)</l>
<l>        *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', ZPlaneMinDepth, ZPlaneMaxDepth, ObjectModel3DThresholded2)</l>
<l>        *pose_to_hom_mat3d (Pose_primitive_plane, HomMat3D)</l>
<l>        *affine_trans_object_model_3d (ObjectModel3DThresholded2, HomMat3D, ObjectModel3DAffineTrans)</l>
<l>        ObjectModel_Scene := TriangulatedObjectModel3D1</l>
<l>    else</l>
<l>        RGB_Scene := RGBA</l>
<l>        ObjectModel_Scene := ObjectModel_Scene</l>
<l>        ObjectModel3D_Result := ObjectModel_Scene</l>
<l>        xyz_to_object_model_3d (X, Y, Z, ObjectModel_Scene)</l>
<l>        *select_points_object_model_3d (ObjectModel_Scene, 'point_coord_x', Index1, Index1+ScanXArea, ObjectModel_Scene)</l>
<l>        sample_object_model_3d (ObjectModel_Scene, sampleMethod, sampleValue, [], [], ObjectModel_Scene)</l>
<c>    </c>
<l>*        smooth_object_model_3d (ObjectModel_Scene, 'mls', ['mls_kNN','mls_force_inwards'], [60,'true'], ObjectModel_Scene)</l>
<l>        *triangulate_object_model_3d (ObjectModel_Scene, 'xyz_mapping', [], [], TriangulatedObjectModel3D1, Information)</l>
<l>        *fit_primitives_object_model_3d (ObjectModel_Scene, 'primitive_type', 'plane', ObjectModel3DOut)</l>
<c>        </c>
<l>        *get_object_model_3d_params (ObjectModel3DOut, 'primitive_parameter_pose', Pose_primitive_plane)</l>
<c>        </c>
<l>        *pose_invert (Pose_primitive_plane, PoseInvert_primitive_plane)</l>
<l>        *pose_to_hom_mat3d (PoseInvert_primitive_plane, HomMat3D_invert)</l>
<l>        *affine_trans_object_model_3d (ObjectModel_Scene, HomMat3D_invert, Triangulated_ObjectModel3DAffineTrans)</l>
<c>        </c>
<l>        *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 1, 5, ObjectModel3DThresholded2)</l>
<l>        *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', 5, 50, ObjectModel3DThresholded2)</l>
<l>        *select_points_object_model_3d (Triangulated_ObjectModel3DAffineTrans, 'point_coord_z', ZPlaneMinDepth, ZPlaneMaxDepth, ObjectModel3DThresholded2)</l>
<l>        *pose_to_hom_mat3d (Pose_primitive_plane, HomMat3D)</l>
<l>        *affine_trans_object_model_3d (ObjectModel3DThresholded2, HomMat3D, ObjectModel3DAffineTrans)</l>
<l>        *ObjectModel_Scene := ObjectModel3DAffineTrans</l>
<l>    endif</l>
<c></c>
<l>    get_object_model_3d_params (ObjectModel_Scene, 'num_points', Scene_PointNum)</l>
<c>    </c>
<l>    if(Scene_PointNum &lt;= 0)</l>
<l>        RGB_Scene := RGBA</l>
<l>        ObjectModel_Scene := ObjectModel_Scene</l>
<l>        ObjectModel3D_Result := ObjectModel_Scene</l>
<c>        </c>
<l>        MatchResult := 'Faild, ' + Scene_PointNum</l>
<l>        return()</l>
<l>    endif</l>
<l>    *find_surface_model_image(img2D, SFM, ObjectModel_Scene, RelSamplingDistance, KeyPointFraction, MinScore, 'true', ['num_matches', 'scene_normal_computation'], [NumMatch, 'mls'], Pose, Score, SurfaceMatchingResultID)</l>
<l>    find_surface_model (SFM, ObjectModel_Scene, RelSamplingDistance, KeyPointFraction, MinScore, 'true', ['num_matches', 'scene_normal_computation'], [NumMatch, 'mls'], Pose, Score, SurfaceMatchingResultID)</l>
<c></c>
<l>    if (Score!=[])</l>
<c>        * Preparing the result(s)</c>
<l>        if (Score[0] &lt; MinScore)</l>
<l>            RGB_Scene := RGBA</l>
<l>            ObjectModel_Scene := ObjectModel_Scene</l>
<l>            ObjectModel3D_Result := ObjectModel_Scene</l>
<c>            </c>
<l>            MatchResult := 'Faild, ' + Score[0]</l>
<l>            return()</l>
<l>        endif</l>
<c>        </c>
<l>        tuple_length(Score, SuccessNum)</l>
<l>        VisRotationCenters := []</l>
<l>        CPose := []</l>
<l>        StartNUM := 0</l>
<l>        EndNUM := 6</l>
<l>        for Index := 0 to SuccessNum-1 by 1</l>
<l>                *CPose[Index] := Pose[0:6]    </l>
<l>            CPose := Pose[StartNUM:EndNUM]</l>
<l>            rigid_trans_object_model_3d (ObjectModel3D, CPose, ObjectModel3D_Result)</l>
<l>            get_object_model_3d_params (ObjectModel3D_Result, 'center', VisRotationCenter)</l>
<l>            VisRotationCenters := [VisRotationCenters,VisRotationCenter]</l>
<l>            StartNUM := StartNUM + 7</l>
<l>            EndNUM := EndNUM + 7</l>
<l>        endfor</l>
<l>        rigid_trans_object_model_3d (ObjectModel3D, Pose, ObjectModel3D_ResultImg)</l>
<c>   </c>
<l>        RGB_Scene := RGBA</l>
<l>        ObjectModel_Scene := ObjectModel_Scene</l>
<l>        ObjectModel3D_Result := ObjectModel3D_ResultImg</l>
<c>        </c>
<l>        VisStart := 0</l>
<l>        PoseStart := 3</l>
<c>        </c>
<l>        SavePoseUR := []</l>
<l>        for Index := 0 to SuccessNum-1 by 1</l>
<l>            SavePose := []</l>
<l>            SavePose[0] := VisRotationCenters[VisStart]</l>
<l>            SavePose[1] := VisRotationCenters[VisStart+1]</l>
<l>            SavePose[2] := VisRotationCenters[VisStart+2]</l>
<l>            SavePose[3] := Pose[PoseStart]</l>
<l>            SavePose[4] := Pose[PoseStart+1]</l>
<l>            SavePose[5] := Pose[PoseStart+2]</l>
<l>            SavePose[6] := 0</l>
<c>            </c>
<l>            *Pose := [VisRotationCenters[VisStart], VisRotationCenters[VisStart+1], VisRotationCenters[VisStart+2], Pose[PoseStart], Pose[PoseStart+1], Pose[PoseStart+1] ,0]</l>
<l>            convert_pose_type (SavePose, 'Rp+T', 'rodriguez', 'point', PoseRodriguez)</l>
<l>            RodLeng := sqrt(sum(PoseRodriguez[3:5]*PoseRodriguez[3:5]))</l>
<l>            AngleInRad := 2*atan(RodLeng)</l>
<l>            UnitAxisOfRotation := PoseRodriguez[3:5]/RodLeng</l>
<l>            OrientationVector := UnitAxisOfRotation*AngleInRad</l>
<l>            PoseUR := [PoseRodriguez[0:2], OrientationVector]</l>
<l>            SavePoseUR := [SavePoseUR, PoseUR]</l>
<l>            VisStart := VisStart + 3</l>
<l>            PoseStart := PoseStart + 7</l>
<l>        endfor</l>
<l>        SavePoseStart := 0</l>
<l>        RTVal := []</l>
<l>        for Index := 0 to SuccessNum-1 by 1</l>
<l>            strMerged := Index+','+ \
                     Score[Index]+','+ \
                     SavePoseUR[SavePoseStart]+','+ \ 
                     SavePoseUR[SavePoseStart+1]+','+ \
                     SavePoseUR[SavePoseStart+2]+','+ \
                     SavePoseUR[SavePoseStart+3]+','+ \
                     SavePoseUR[SavePoseStart+4]+','+ \
                     SavePoseUR[SavePoseStart+5]</l>
<l>            RTVal := [RTVal, strMerged]</l>
<l>            SavePoseStart := SavePoseStart + 6</l>
<l>        endfor</l>
<l>        MatchResult := RTVal</l>
<l>    else</l>
<l>        RGB_Scene := RGBA</l>
<l>        ObjectModel_Scene := ObjectModel_Scene</l>
<l>        ObjectModel3D_Result := ObjectModel_Scene</l>
<c>        </c>
<l>        MatchResult := 'Faild, Not Matched'</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>return()</l>
</body>
<docu id="SurfMatch_FileHandle_0_0_4">
<parameters>
<parameter id="BOXLengthX"/>
<parameter id="BOXLengthY"/>
<parameter id="BOXLengthZ"/>
<parameter id="CreateSFMSampleVal"/>
<parameter id="CylinderRadius"/>
<parameter id="CylinderZMaxExt"/>
<parameter id="CylinderZMinExt"/>
<parameter id="FindMethod"/>
<parameter id="KeyPointFraction"/>
<parameter id="MatchForm"/>
<parameter id="MatchResult"/>
<parameter id="MinScore"/>
<parameter id="NumMatch"/>
<parameter id="ObjectModel3D_Result"/>
<parameter id="ObjectModel_Scene"/>
<parameter id="RGB_Scene"/>
<parameter id="ROIXAreaMax"/>
<parameter id="ROIXAreaMin"/>
<parameter id="ROIYAreaMax"/>
<parameter id="ROIYAreaMin"/>
<parameter id="ROIZPlaneMaxDepth"/>
<parameter id="ROIZPlaneMinDepth"/>
<parameter id="RelSamplingDistance"/>
<parameter id="RoiForm"/>
<parameter id="ScanXArea"/>
<parameter id="ScanXOverwrap"/>
<parameter id="ScoreWeight"/>
<parameter id="SimpleModelSampleVal"/>
<parameter id="SimpleObjMatch"/>
<parameter id="SphereRadius"/>
<parameter id="om3FileName"/>
<parameter id="plyFilename"/>
<parameter id="sampleMethod"/>
<parameter id="sampleValue"/>
<parameter id="sfmFileName"/>
</parameters>
</docu>
</procedure>
</hdevelop>
